## 内核内存分配
inux内核使用伙伴系统来管理物理内存，分配的单位是页，但其分配的粒度太大，内核又无法借助标准C库，需要用别的手段来实现内核中的动态内存管理。

## slab分配器
slab分配器不仅可以提供动态内存的管理功能，而且可以作为经常分配并释放的内存的缓存

#### slab分配器的优点：
- 提供小内存的分配支持
- 不用每次和伙伴系统打交道，提高了分配效率
- 如果在slab缓存的话，其在CPU高速缓存的概率也较高
- 伙伴系统分配的页地址都是页的倍数，这对CPU的高速缓存的使用有负面影响。（考虑以下情况：如果每次将数据放置在页开始的地方，会使得有些Cache Line会过度使用，而有些Cache Line几乎不被使用，导致Cache的命中率降低）==slab分配器通过着色使得对象能够均与地使用Cache==.

#### slab家族
- ==slob==：针对嵌入式系统优化过的slab算法，降低了复杂度，使用内存块链表，并使用最先适配算法。
- ==slub==：将页帧打包为组，在大型计算机上，slub提供比slab更高的性能。


## slab分配器设计

#### 高速缓存设计
![image](https://img-blog.csdn.net/20160929222025695)
- slab分配器把对象分组放进高速缓存，每一块高速缓存`kmem_cache_t`都是同种类型对象的一种“储备”。（例如socket对象、打开的文件标识符等等）
- 每个高速缓存的主内存区被划分为多个slab，每个slab由一个或者多个页框组成，其中既包含已分配的对象，又包含空闲的对象。
- 在每个高速缓存`kmem_cache_t`结点中，slab是通过3个链表组织起来的，`kmem_cache_t`中较为重要的两个成员：
```c
//每CPU指针数组指向包含空闲对象的本地高速缓存
struct array_cache * array[];

//组织slab分配器的链表数据结构
struct kmem_list3 lists;
```
- 这个array是扮演着十分重要的角色，数组中的元素为per-cpu中的空闲对象集合（每个CPU都会有一个数组，这是为了充分利用cache），在分配和释放对象时采用LIFO，内核假定刚刚释放的对象还在CPU高速缓存中，下一次分配时将优先进行分配（充分利用了CPU高速缓存），只有当per-cpu数组为空时，才会去使用到slab分配器中的空闲对象。==于是申请对象时会经历以下三个层次结构，分配成本将会逐级增加==：

1. 仍然处于CPU高速缓存中的per-cpu空闲对象
2. 现存slab分配器中的空闲对象
3. 使用伙伴系统分配的新slab分配器

#### slab分配器设计
![image](https://img-blog.csdn.net/20160929222055586)

- slab中的对象并非连续排列，而是一种相当复杂的排布方案。==进行填充以满足某种对齐方式==：要求按照硬件缓存行size对齐、按该机器void *的大小进行对齐。
- slab利用未用字节free对slab着色，用于再细分slab，并允许内存分配器把对象展开在不同的线性地址之中，以充分发挥硬件cache的性能。


## 先有鸡还是先有蛋？
初看slab分配器的初始化应该不是特别复杂，因为此时伙伴系统已经启动，但是，slab的数据结构属于小内存，本身最适合用slab分配器进行分配，而此时slab分配器又还没有准备好。

#### `kmem_cache_init`初始化slab分配器
==多步骤逐步激活slab分配器==：
- `kmem_cache_init`创建了系统第一个slab缓存，以便为kmem_cache的实例提供内存，此时内核采用的技巧是为其分配static静态变量，当slab分配器初始化完成后再改用动态分配。


## 实现的细节

#### 创建缓存`kmem_cache_create()`
```c
mm/slab.c
struct kmem_cache *kmem_cache_create(const char *name,
                                     size_t size,
                                     size_t align,
                                     unsigned long flags,
                                     void (*ctor)(void *));
```
需要提供缓存的名字、缓存中每个元素的大小、slab第一个元素的偏移（默认为0，用于页对齐）、配置项、高速缓存的构造函数（新页追加到高速缓存时调用）

#### 给高速缓存分配slab `cache_grow()`
当满足：发出分配新对象请求，但高速缓存中已经不包含任何空闲对象时，会调用`cache_grow()`函数来给高速缓存分配一个新的slab，大致流程为：调用`kmem_getpages()`从分区页框中分配一组页框用于存放slab，获得新的slab描述符，并添加到该高速缓存的全空slab链表的末尾。

#### 从高速缓存中释放slab `slab_destory()`
当slab高速缓存中有太多的空闲对象，或者被周期性调用的守护进程确定有完全未使用的slab，此时调用`slab_destroy()`撤销一个slab，并释放页框至内核。

#### 分配对象`kmem_cache_alloc()`
```c
void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags);
```
首先试图从本地高速缓存中获得一个空闲对象（LIFO原则，上面有描述过，目的是充分利用硬件cache），若无空闲对象，则需要从高速缓存的空slab链表或者部分填充slab链表中，获得slab并分配空闲对象，如果有必要则要新申请一个slab.

#### 释放对象`kmem_cache_free()`
上述步骤的反过程

#### 通用对象分配释放接口`kmalloc/kfree`
普通高速缓存中的对象具有几何分布的大小32~131072字节，该函数为所请求的大小分配最近的2的幂次方大小的内存，然后调用`kmem_cache_alloc()`分配对象。这里所分配的内存物理上是连续的。
