## 中断与异常
#### 区分！
- 中断：外部的，由IO设备产生，目的是为了支持CPU和设备的并行工作，CPU启动输入输出后，设备便可独立开始工作，当设备工作结束后，以中断的形式通知CPU，期间CPU可以转而去做其他事情。
- 异常：内部的，是程序的错误或者内核必须处理的异常条件产生，程序的错误内核通过发送信号来处理异常，而后者需要内核执行恢复异常需要的所有步骤，例如缺页。

#### Intel手册对中断和异常的分类
- 中断：可屏蔽的（IO设备）、非屏蔽的（危机的，例如硬件故障）
- 异常：
1. 处理器探测异常：==故障fault==（可以纠正，一旦纠正程序可以不失连贯性的重新执行，例如缺页），==陷阱trap==（主要用途是调试程序，陷阱指令执行后立即报告，返回时程序将不失连贯性地从下一条指令开始执行），==异常终止abort==（报告严重的错误，除了终止进程外别无选择）
2. 编程异常：执行系统调用、或者通报一个特定的事件。

![image](https://img-blog.csdnimg.cn/20190328033643556.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTk2Mjg1,size_16,color_FFFFFF,t_70)

#### 中断和异常的硬件处理
- 控制单元检测到中断或异常：
1. 确定向量i，0 <= i <= 255
2. idtr寄存器指向IDT表，读取第i项获得处理函数的入口地址
3. 特权级检查，CPL需要大于等于DPL，否则产生General Protection异常。即：中断处理程序的特权级不能低于引起中断的程序的特权。
4. 栈中保存：eflags、cs、eip内容
5. 根据中断处理函数的入口地址装载cs、eip，开始执行

- 交还控制权的iret：
1. 弹出栈中保存的内容并装载相应寄存器，检查特权级略。

#### Linux中断描述符分类：5类
- 中断门：DPL=0，内核态激活，用户态进程不能访问；
- 系统门：DPL=3，用户态可以访问的Intel陷阱门，可以通过此执行系统调用；
- 系统中断门：DPL=3，用户态可以访问的Intel中断门，int 3
- 陷阱门：DPL=0；
- 任务门：Linux对Double fault异常的处理程序是由任务门激活的；

这些中断门初始化时首先均填充为ignore_int()处理函数，该函数几乎什么都不做，随后使用真正有意义的中断或异常处理程序替换之。

#### 异常处理
80x86发布了大约20种异常，内核为每一种异常提供了专门的异常处理程序，对于某些异常，CPU控制单元会在开始执行时产生一个硬件出错码并且压入内核态堆栈。异常处理程序的标准结构：
- 使用汇编代码在内核堆栈中保存大多数寄存器的内容
- call高级的C函数处理异常
- 通过ret_from_exception()从异常处理程序中退出。

#### 中断处理
与处理异常不同的是（大多数异常只需要给进程发送Unix信号即可），中断不能采用这种处理方式，因为经常会出现一个进程被挂起好久中断才到达的情况（例如数据传输进程）。中断处理依赖于中断类型：I/O中断、时钟中断、处理器间中断。

###### I/O中断处理
不是所有的中断操作都具有紧迫性，需要时间长的、非重要的操作应该推后；更重要的是：中断处理程序代表进程执行，此时进程状态为TASK_RUNNING，不能执行任何阻塞，例如磁盘I/O操作。标准结构：
- 内核态堆栈中保存IRQ的值和寄存器内容；
- 给正在IRQ线服务的PIC发送一个应答，这将允许PIC进一步发出中断；
- 执行共享这个IRQ的所有设备的中断服务例程ISR
- 跳到ret_from_intr()后终止。

###### 保存寄存器的值
内核初始化时建立Interrupt数组，该数组包含NR_IRQS个元素，每个元素有两条汇编指令：
```
pushl $n-256
jmp common_interrupt
```
这里第一条指令对应保存IRQ值，第二条common_interrupt为：
```
common_interrupt:
    SAVE_ALL
    movl %esp, %eax
    call do_IRQ
    jmp ret_from_intr
```

这个SAVE_ALL宏定义展开后进行其他寄存器的保存，除了SS,SP,EFLAGS,CS,IP，因为这些已经又硬件自动保存了。

###### `do_IRQ()`函数

###### `__do_IRQ()`函数
该函数通过eax传递的IRQ号执行真正的中断处理函数，其中复杂之处在于处理多处理器情况，设备驱动程序的中断服务例程不需要是可重入的，正是因为__do_IRQ()的控制。还要考虑挽回丢失的中断的情形，该情形发生在CPU1应答中断之前，这条IRQ线被另一个CPU2所屏蔽，导致最终CPU1没有执行中断服务例程。解决方法时，当重新enable这条IRQ线时会检查是否发生了中断丢失，这可以通过检查IRQ_PENDING位实现（被CPU1所设置），若确实发生了中断丢失，则强迫硬件让丢失的中断再产生一次。

## 中断下半部实现机制
在内核执行的几个任务之间有些不是紧急的，如果ISR运行时间过长，则会造成明显的卡顿，所以规定了中断处理程序中不能存在sleep、阻塞等，必要情况下可以延迟一段时间。这些可延迟的中断可以在开中断的情况下执行，从中断处理程序中抽出来有助于使内核保持较短的响应时间。可延迟中断函数包含：软中断、tasklets、工作队列。

#### 软中断
- 软中断由编译时静态定义，可以并发地运行在多个CPU上，因此软中断处理函数必须是可重入的，并且使用自旋锁提供保护。目前只有两个子系统使用到了软中断：网络和SCSI.
- 软中断可以主动换起raise_softirq()，也应该周期性地又不能太频繁地检查，例如内核调用local_bh_enable()、或者调用irq_exit()时，会检查是否满足软中断条件，若满足则进行处理。
- 软中断执行函数`do_softirq()`：为了保证可延迟函数的低延迟性，该函数将一直运行到执行完所有挂起的软中断，但又为了限制其一次运行很长时间，只先做固定的循环次数（例如10次），剩余的交给ksoftirqd.
- `ksoftirqd`内核线程：每个CPU都有自己的`ksoftirqd`内核线程，该线程的目的是为重要而难以平衡地问题提供了解决方案：若每次`do_softirq()`只处理一个软中断，则对网络开发者不友好，只有等下个时钟中断到来之时才会又得到执行，该等待时间是不可接受的；而若每次`do_softirq()`都处理完所有挂起的软中断，则会造成普通用户的高延迟；现在`ksoftirqd`内核线程做以下平衡：内核线程具有较低的优先级，用户程序在`do_softirq()`处理完较少次数的软中断后可以得到执行，当机器空闲时，`ksoftirqd`得到调度执行，剩余挂起的软中断得到执行。


#### tasklet
![image](https://pic1.zhimg.com/80/v2-6115bef7ffcfe11bb39dca4946734a18_720w.jpg)

- tasklet是I/O驱动程序中实现可延迟函数的首选方法，Linux内核对其进行了严格的控制：相同类型的tasklet总是被串行执行，因此tasklet函数不必是可重入的，简化了设备驱动程序开发者的工作。（但不同类型的tasklet是可以在几个CPU上并发执行的）
- 如果驱动程序开发者需要使用tasklet，首先要使用内核提供的API完成tasklet的注册，`tasklet_action()`函数将作为TASKLET_SOFTIRQ软中断处理函数在一个合适的推迟时间点被执行，该函数扫描tasklet链表，对链表每一个注册的结点调用回调函数。


#### 工作队列
- 与可延迟函数的区别在于：可延迟函数运行在中断上下文中，而工作队列的函数运行在进程上下文中。执行例如访问磁盘数据块的可阻塞函数的唯一方式是在进程上下文中运行，因为在中断上下文中不可能发生进程切换。于是工作队列函数是可阻塞的，弥补了软中断机制的缺陷。
- 绝大多数情况下可以不用自己去创建工作队列，可以使用预定义events工作队列，除了一般的events队列，Linux中还有一系列专用的工作队列，例如块设备层使用的kblockd.



