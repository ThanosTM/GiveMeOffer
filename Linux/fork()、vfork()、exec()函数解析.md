## fork函数

#### 原型
```c
#include<unistd.h>
pid_t fork(void)
```

#### 函数功能
以当前进程作为父进程创建一个新进程，子进程作为父进程的一个副本存在，PID不同

#### 返回值
pid == 0：子进程执行
pid > 0：父进程执行，返回子进程的pid
pid < 0：调用失败

## 底层实现
#### fork步骤
1. 分配新的内存块和内核数据结构给子进程
2. 将父进程部分数据结构内容拷贝至子进程
3. 添加子进程到系统进程列表当中
4. fork返回，开始调度器调度

#### 底层
![image](https://img-blog.csdn.net/20180807115631731?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3OTY0NTQ3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

#### 写时拷贝技术, COW, Copy-On-Write
并不执行父进程数据段、栈、堆的完全副本，父进程与子进程共享页帧（只读），父子进程试图写一个被保护的页帧时，产生一个异常，内核将该页复制到一个新页帧中并标记为可写。

## 其他
#### 文件共享
- 父进程和子进程共享同一个文件偏移量
- fork()之后处理文件描述符的两种方式：
1. 父进程等待子进程完成，父进程无需做任何处理
2. 父子进程各自执行不同的程序段，需要各自关闭不再使用的文件描述符，确保不会干扰对方的使用，经常用于网路服务进程。

#### fork()函数的两个用法
- 父进程希望复制自己，父子进程同时执行不同的代码段，常用于网路服务器编程，父进程等待客户端服务请求，请求到达时fork子进程进程处理，自己继续等待下一个服务请求
- shell：fork()后立即调用exec()，执行不同的程序

## vfork()函数
#### 起源
vfork()函数来源于一个历史问题，最初的fork()函数没有采用写时复制的方法，将完整地复制父进程的所有地址空间，而经常子进程会立即调用exec()函数（shell中），使得刚复制进来的地址空间被覆盖，导致了浪费。而vfork()

#### 区别
- fork()拷贝父进程和子进程的地址空间（即使写时复制实现了部分复制，但还是比vfork()要慢），vfork共享
- vfork()确保子进程先运行，而fork()的运行顺序是取决于操作系统的调度算法的。

#### 这个函数是有瑕疵的，不推荐使用
- 子进程修改数据、函数调用、没有调用exec()或exit()都会带来未知的结果
- vfork确保子进程先运行，在调用exec()或exit()后父进程才可能被调度执行，若子进程在此之前依赖父进程的进一步动作则导致死锁。

## exec()函数
- exec()并不创建新进程，只是使用磁盘上的新程序替换了当前进程的正文段、数据段、堆段和栈段

- shell模板：

```c
if((pid = fork()) < 0){
    err_sys("fork error");
}
else if(pid == 0){
    execlp(buf, buf, (char *)0);
    err_ret("couldn't execute: %s", buf);
    exit(127);
}

if((pid = waitpid(pid, &status, 0)) < 0)
    err_sys("waitpid error");
```

