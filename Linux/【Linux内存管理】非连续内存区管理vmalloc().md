## 非连续内存区管理
把内存区映射到一组连续的页框是最好的选择，这样可以充分利用硬件cache并获得较低的平均访存时间；而==提供连续的线性地址访问非连续的页框这一分配模式也会很有意义==，主要有点是避免了外部碎片，缺点是必须打乱内核页表。

#### 非连续内存区分配函数`vmalloc()`
Linux多处使用`vmalloc()`用于给模块分配空间或者给某些I/O驱动程序分配缓冲区。因为当模块数比较多，同时系统又运行了比较长时间的情况下，无法保证有足够的连续物理页框，此时可以用`vmalloc()`解决该问题；`vmalloc()`使用`ZONE_HIGHMEM`内存域进行映射，因为可以节省宝贵的较低端的内存区域。

![image](https://img-blog.csdn.net/20160929211548071)

如图，从物理内存映射的末尾到第一个VMALLOC区之间有一个8MB的==安全区==，同时每一个VMALLOC区之间也插有4KB大小的安全区，目的均为==捕获对内存的越界访问==。

#### 非连续内存区管理数据结构`vm_struct`
```c
struct vm_struct {
    struct vm_struct    *next;
    void                *addr;
    unsigned long       size;
    unsigned long       flags;
    struct page         **pages;
    unsigned int        nr_pages;
    phys_addr_t         phys_addr;
    const void          *caller;
};
```
- 通过next字段，这些描述符被插入到一个简单的链表中，第一个元素放在vmlist变量中；
- flags字段表示非连续区映射的内存类型，VM_ALLOC、VM_MAP、VM_IORMAP

![image](https://img-blog.csdn.net/20160929211618447)

#### `vmalloc()`的执行流程
- 将传入参数size设置为4096即页框大小的整数倍
- 调用`get_vm_area()`创建一个新的标识符，返回分配给这个内存区的线性地址。具体流程为：
1. 使用`kmalloc()`为`vm_struct`分配内存区
2. 扫描链表，获得至少覆盖size+4096个地址的线性地址空闲区域（这里4096位留出的安全区大小）
3. 成功则初始化描述符字段，并返回起始地址
4. 失败则释放申请到的`vm_struct`，并返回NULL

- 调用`kmalloc()`函数请求一组连续的页框，用于足够包含一个页描述符指针数组；
- 重复调用`alloc_page()`为区间中的每一页分配一个页框，这些页框未必是连续的；
- 此时已经得到了一个新的连续线性地址空间，并且已经分配了一组非连续的页框来映射，接下来的事情自然是记录这些映射。方法是修改内核使用的页表项，完成这些映射，这是`map_vm_area()`函数所做的。


## 备选映射方法
- `vmalloc_32()`，工作方式与`vmalloc()`相同，但总是保证所使用的物理内存可以被普通32位指针寻址，在一些特定的体系结构中使用；
- `vmap()`：与`vmalloc()`中隐式分配页框不同，`vmap()`需要预先分配好物理页框，并作为参数传入，建立连续虚拟内存到非连续物理内存的映射；
- `ioremap()`：可以将取自物理地址空间、由系统总线用于I/O操作的一个内存块，映射到内核地址空间中；

