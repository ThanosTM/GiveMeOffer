## 笔试情况
- 2小时5题，做个稀烂
- 第一题，二叉树到某一结点的路径，100%
- 第二题，某种数字变换雷题目，自己的测试样例全对，提交上去0%
- 第三题，topK问题的进化版，80%通过，剩余超时了
- 第四题，输出最大的奖金中位数，没时间
- 第五题，挑选最大商品总额，没时间

## 第一题
给定一颗二叉树TreeNode *root，二叉树每个结点的值都不相同，给定一个查询向量b，对于b中所给的每个元素，均要输出从root出发到对应结点的路径，以链表ListNode的方式返回

解题框架：
```cpp
vector<ListNode *> solve(TreeNode *root, vector<int> &b){
    
    //TODO
    
}
```

示例：
```
输入root:
        1
      /   \
     2     3
    / \   / \
   4   5 6   7
输入b：{1,2,3,4,5,6,7}

输出[{1}, {1,2}, {1,3}, {1,2,4}, {1,2,5},
    {1,3,6}, {1,3,7}]
```

## 第二题
第一行为数字T，1<= T <= 2000，表明有T个测试样例，接下来T行为正整数n，1<=n<=1e9，对于每个n输出以下问题的解：

你可以通过以下三种变换，使得这个数字变为0，现在想知道最少需要几次：
- 第一种变换：n = n - 1
- 第二种变换，如果n是偶数，n = n / 2
- 第三种变换，如果n是3的倍数，n = n / 3

示例：

```
输入：
1
10

输出：
4

解释：10->9->3->1->0,4次
```

## 第三题
- 第一行包含一个正整数n，1 <= n <= 1e5，表示给定n个数组
- 接下来n行，每一行都表示一个数组，其中第一个元素为这一行数组的长度mi，1 <= mi <= 1e5，后面的mi个正整数aij(1 <= aij <= 1e9)，表示该行元素的第j个元素
- 接下来1行，给出一个正整数q，1 <= q <= 1e5，表示询问次数
- 接下来q行，每一行表示一次询问，第一个正整数pi, 1 <= pi <= n，表示需要合并的数组个数，接下来pi个正整数bij，1 <= bij <= n，表示需要合并的数组的下标，最后一个正整数ki，表示需要输出合并后数组的第k小的元素

示例：
```
输入
5
1 1
2 2 3
3 5 10 6
4 4 58 2 1
5 1000000000 9 8 4 5
5
1 2 2
2 2 3 3
3 3 4 5 11
4 5 4 3 2 1
5 1 2 5 4 3 7

输出：
3
5 
58
1
4
```

## 第四题
- 第一行给出两个正整数，分别为员工数n和奖金总数w，接下来n行，每行两个正整数分别为第i个员工的奖金下限x[i]，和上限y[i]
- 要求：一种奖金分配方式，使得每个人的奖金在上下限之间，同时使得所有员工拿到奖金的中位数最大，求最大的中位数。

示例：
```
输入：
3 20
8 10
1 4
7 9

输出：
9

解释：分别发放10，1，9，奖金中位数是9
```

## 第五题：自己做了一些简化
一共n件商品，价格分别为wi，现在规定一个正整数m，需要从n件商品中挑选最大的价格和使得是m的倍数

- 第一行T，T个测试样例
- 接下来每一组测试样例有两行，第一行是两个正整数n和m，表明有n件商品，m的倍数
- 第二行是n件商品的价格

示例：
```
输入：
2
3 3
3 6 9
3 5
9 6 3

输出：
0
3

解释：
1. 3件商品3,6,9，总价18，正好是3的倍数，剩下0元
2. 3件商品9,6,3，总价18，需要为5的倍数，最多只能选9+6=15，剩下3元
```




