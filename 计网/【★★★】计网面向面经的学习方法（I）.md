## 1、浏览器输入网址之后发生了什么
#### DNS解析：URL --> IP地址
根据以下顺序查询URL对应的IP地址，==遵循就近原则：== 浏览器缓存 --> 操作系统缓存 --> 路由器缓存-->本地（ISP）域名服务器缓存 --> 本地服务器以此向根域名服务器、顶级域名服务器、权威域名服务器迭代查询，知道获得对应的IP地址。

#### 建立TCP连接：HTTP建立于TCP之上，端口80
浏览器取得服务器IP地址，发起TCP连接，经过三次握手建立起TCP连接。首先发送一个SYN数据包给服务器，包含客户端随机初始序号，服务器收到SYN返回SYNACK包，包含服务器随机初始序号，客户端再发送ACK包进行确认。（HTTPS还将进行TLS握手）

#### 发起HTTP请求
HTTP请求报文：请求行（方法+URL+HTTP版本）+首部字段+（空行）+ 实体

- 方法：
1. GET:获取资源
2. POST:传输实体主体
3. HEAD:获取报文首部
4. PUT:传输文件
5. DELETE:删除文件
6. OPTIONS:询问支持的方法
7. TRACE:追踪路径

- 首部字段
1. Host（必需）：对象所处主机
2. User-Agent：用户代理（浏览器）
3. Connection：连接属性
4. Cookies：用户登录信息

#### 接收响应结果
HTTP响应报文：状态行（HTTP版本+状态码+状态短语）+首部字段+（空行）+实体

- 常用状态码：2XX——一切正常，3XX——重定向，4XX客户端错误，5XX服务器错误
1. 200：OK 请求正常处理
2. 404：Not Found无法找到请求资源
3. 304：Not Modified 缓存中读取

#### 浏览器HTML解析渲染
浏览器是一个及其庞大的软件，例如谷歌Chrome浏览器是一个多进程多线程架构软件，内核包含渲染引擎Blink，JavaScript引擎V8。


## 2、HTTP和HTTPS区别
#### HTTPS简介
什么是HTTPS，以安全为目标的HTTP，在HTTP上加入了SSL/TLS层，提供内容加密、身份认证、数据完整性的安全性功能。为了实现安全性，HTTPS比HTTP慢。

#### SSL与TLS
- SSL，Secure Socket Layer，安全套接字层

建立在可靠传输协议TCP之上，具体内容见思维导图，当前版本为3.0

- TLS，Transport Layer Security，传输层安全协议

建立在SSL3.0上，可以认为是SSL3.1。

- TLS相对SSL有哪些改进？
1. 更安全的MAC算法
2. 增强的伪随机功能PRF
3. 更严密的警报
4. 等等

#### 主要区别
1. https协议需要到CA申请证书，一般免费证书较少，因而需要一定费用。

2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl/tls加密传输协议。

3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4. http的连接很简单，是无状态的；HTTPS协议是由SSL/TLS+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

#### HTTPS通信过程
1. 客户端向服务器端发出请求：支持的版本协议、加密算法、MAC算法，一个客户端随机数
2. 服务器响应：选用的版本协议、加密算法、MAC算法，SSL证书，服务器随机数
3. 客户端回应：SSL证书校验，提取公钥，公钥加密的随机选取的前主密钥，客户端握手结束通知（前面所有内容的散列值，供服务器校验）
4. 服务器回应握手结束通知（前面所有内容的散列值，供客户端校验）
5. 客户端和服务器各自分别导出主密钥

#### HTTPS的缺点
1. 握手耗时
2. SSL证书需要钱
3. SSL证书需要绑定IP地址，不能在同一IP上绑定多个域名
4. 加密的范围比较有限，SSL证书的信用链体系并不安全

#### 如何优化HTTPS的速度
- HSTS重定向技术，将HTTP自动转换为HTTPS，减小301重定向
- TLS握手优化：抢先技术，在TLS握手完成前客户端就提前向服务器发送数据
- Session Identifier（会话标识符）复用：服务器维护ID，下次连接客户端发ID过来可以直接沿用之前的密钥
- 开启OCSP Stapling，在线证书状态协议，服务端主动获得OCSP查询结果并下发给浏览器，省去了浏览器在线验证的过程

#### 数字证书
###### 目的
需要一个权威的值得信赖的第三方机构统一对外发放主机机构的公钥，使得请求方确信公钥是从目标主机发送过来的且没有被篡改过

###### 证书包含的内容
证书颁发机构名称、证书本身的数字签名、证书持有者公钥、证书签名用到的Hash算法

###### 验证证书的有效性
浏览器默认内置CA根证书，包含了CA的公钥
1. 证书的颁发机构是伪造的，浏览器不认识并发出警告
2. 证书的颁发机构是确实存在的，则根据CA名找到内置的CA根证书和CA公钥，对证书的摘要进行解密，若解密失败则认为是危险证书
3. 对于篡改的证书，则分别计算数字签名的解密得到摘要A，和根据签名的Hash算法得到证书的摘要B进行比对
4. 证书可以在过期前被吊销，通常情况是该证书的公钥已经失密，浏览器根据OCSP在线验证排除这种情形

###### 证书链
证书以链的方式存在，从上到下是CA根证书，二级CA，终端用户证书，每个证书为下一层证书的合法性做担保，有且仅有证书链上的每个证书均合法，才会认定当前证书合法

#### 中间人攻击
![image](http://www.2cto.com/uploadfile/Collfiles/20160707/20160707090854346.jpg)
###### 伪造证书
如果导入了攻击者的公钥证书到客户端，该伪造证书就能完美通过客户端的证书校验
###### 防止：
- 不要轻易安装其他网站的证书
- APP证书校验：
1. 查看证书是否过期——服务器证书上的域名是否和服务器的实际域名相匹配——校验证书链
2. 更安全的校验方式：将服务端证书打包到APP中，再讲本地证书和服务端证书比对
3. 第二种方式的维护问题：服务器证书过期、证书更换、APP不升级则无法使用。修改：生成一对公钥私钥，公钥硬编码在APP中，私钥放在服务器，HTTPS握手前先下发私钥签名的证书信息，app分别计算公钥解密的证书信息和HTTPS握手阶段获得的证书信息进行比对。


## 3、TCP的三次握手与四次挥手
#### 三次握手
![image](https://img-blog.csdnimg.cn/20190613001840993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlZmZpbg==,size_16,color_FFFFFF,t_70)
- 第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。
- 第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。
- 第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。

#### TCP三次握手中为什么客户端和服务器要各自选择一个随机初始序号？
如果TCP在建立连接时每次都选择相同的、固定的初始序号，那么设想以下的情况：   (1)假定主机A和B频繁地建立连接，传送一些TCP报文段后，再释放连接，然后又不断地建立新的连接、传送报文段和释放连接。   (2)假定每一次建立连接时，主机A都选择相同的、固定的初始序号，例如，选择1。   (3)假定主机A发送出的某些TCP报文段在网络中会滞留较长的时间，以致造成主机A超时重传这些TCP报文段。   (4)假定有一些在网络中滞留时间较长的TCP报文段最后终于到达了主机B，但这时传送该报文段的那个连接早已释放了．而在到达主机B时的TCP连接是一条新的TCP连接。   ==这样，工作在新的TCP连接下的主机B就有可能会接受在旧的连接传送的、已经没有意义的、过时的TCP报文段(因为这个TCP报文段的序号有可能正好处在现在新的连接所使用的序号范围之中)。结果产生错误==。   因此，必须使得迟到的TCP报文段的序号不处在新的连接中所使用的序号范围之中。   这样，TCP在建立新的连接时所选择的初始序号一定要和前面的一些连接所使用过的序号不一样。因此，不同的TCP连接不能使用相同的初始序号。

一旦有人掌握了ISN的规律，就能轻易地“伪造”出一个可以扰乱并注入TCP连接的TCP Segment（只要有正确的Socket和Seq Num）。因此，RFC 793这种选定ISN的做法并不可取。当前，大部分操作系统都使用一种半随机的方式去选择ISN。例如Linux和Windows，使用“计时器 + 随机偏移量”的方法来选定ISN。


#### 为什么建立TCP连接需要三次握手，而不是两次？
- 教材中的解释：表因

在谢希仁所著的《计算机网络》中，对这个问题是这么描述的：“==为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误==”

其描述的是这样一种情形：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。

- 本质

为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 ==三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤==

若仅有两次握手，B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的初始序列号将无法达成一致。于是TCP的设计者将SYN这个同步标志位SYN设计成占用一个字节的编号，因此TCP对有数据的TCP Segment必须确认，即A需要确认B的序号。如果B发给A的第二次握手信号或者A发给B的第三次握手信号丢失了，均会造成B的超时重传，直到接收到来自A的ACK信号位置，即完成了双方序号的协商。

#### 四次挥手
![image](https://img-blog.csdnimg.cn/2019061300194375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0dlZmZpbg==,size_16,color_FFFFFF,t_70)
- 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。
- 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。
- 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。
- 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。

#### TCP四次挥手时，客户端为什么需要进入定时等待状态再关闭连接，而不是直接关闭？
1、==为了保证客户端发送的最后一个ACK报文段能够到达服务器==。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL（两倍的最大报文生存时间），而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。

2、他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以==使本链接持续时间内所产生的所有报文段都从网络中消失==。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。


## 4、DDos攻击与防御
分布式拒绝服务，Distributed Denial of Service
#### DDos攻击
将多台计算机联合起来作为攻击平台，通过远程连接利用恶意程序，对一个或多个目标发起DDoS攻击，消耗目标服务器性能或网络带宽，从而造成服务器无法正常地提供服务。

#### 攻击举例：SYN Flood
利用了TCP协议的三次握手机制，当服务端接收到一个Syn请求时，服务端必须使用一个监听队列将该连接保存一定时间。因此，通过向服务端不停发送Syn请求，但不响应Syn+Ack报文，从而消耗服务端的资源。当监听队列被占满时，服务端将无法响应正常用户的请求，达到拒绝服务攻击的目的。

#### 防御
1. 确保服务器的系统文件是最新的版本，并及时更新系统补丁。
2. 关闭不必要服务：只开放服务端口
3. 限制同时打开的SYN半连接数目,缩短SYN半连接的time out 时间,限制SYN/ICMP流量
4. 正确设置防火墙：禁止对主机的非开放服务进行访问、限制特性IP地址的访问、启动防火墙防DDoS属性等
5. 检查网络设备的主机、服务器日志
6. 充分利用网络设备保护网络资源


## 5、Session、Cookie
Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。

#### Cookie
Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie，而客户端浏览器会把Cookie保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。服务器还可以根据需要修改Cookie的内容。

#### Session
客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session，服务器就按照sessionid把这个session检索出来使用；如果客户端请求不包含sessionid，则为此客户端创建一个session并且生成一个与此session相关联的sessionid，并将这个sessionid在本次响应中返回给客户端保存。保存这个sessionid的方式可以采用 cookie机制 ，这样在交互过程中浏览器可以自动的按照规则把这个标识发挥给服务器；若浏览器禁用Cookie的话，可以通过 URL重写机制 将sessionid传回服务器。

#### Session 与 Cookie 的对比
1. 实现机制：Session的实现常常依赖于Cookie机制，通过Cookie机制回传SessionID；
2. 大小限制：Cookie有大小限制并且浏览器对每个站点也有cookie的个数限制，Session没有大小限制，理论上只与服务器的内存大小有关；
3. 安全性：Cookie存在安全隐患，通过拦截或本地文件找得到cookie后可以进行攻击，而Session由于保存在服务器端，相对更加安全；
4. 服务器资源消耗：Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

## 6、路由器和交换机有哪些区别？
交换机实际就是多接口的网桥

（1）外形上

交换机通常端口比较多，路由器端口少体积小，（路由器一般都集成了交换机的功能，LAN口就是作为交换机的端口来使，

WAN用于连接外网的端口。

（2）工作层次不同

交换机在数据链路层（实现数据帧的转发），而路由器在网络层（肩负着网络互连的作用）。

（3）数据的转发对象不同

交换机是根据MAC地址转发数据帧，而路由器是根据IP地址来转发数据报。IP地址决定最终数据要到达某一台主机，而MAC地址是决定下一跳将要交给哪一台设备（一般是交换机或者路由器），IP地址是软件实现的，可以描述主机所在的网络，MAC地址是硬件实现的，每一个网卡在出厂时都会将全世界唯一的MAC地址固化在ROM中，因此MAC不可改，IP可改

（4）分工不同

交换机主要是用于组建局域网，而路由器则负责让主机连接外网，多台主机可以通过网线连接到交换机，这时候就组建好了局域网，就可以通过网线连接到交换机，这时就组建好了局域网，就可以将数据发给局域网中的其他主机，然而通过交换机组建的局域网是不能访问外网的，这时就需要路由器为我们来打开外网大门，局域网的所有主机使用的都是私网的IP,所以必须通过，路由器转换为公网IP之后才能访问外网

（5）冲突域和广播域

交换机分割冲突域，但不分割广播域，而路由器分割广播域。由交换机连接的网段，仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，这时会导致广播风暴和安全漏洞。而连接在路由器上的网段会被分配到不同的广播域。路由器不会转发广播数据。交换机会转发广播数据给局域网中的所有主机，值得说明的是单播的数据包在局域网中会被交换机唯一的送到目标主机，其他主机不会接受到数据，这是区别于原始的集线器的。


## 8、HTTP1.0、HTTP1.1、HTTP2.0
#### HTTP1.1与HTTP1.0的对比
###### 缓存处理
相较于HTTP1.0采用了更多的缓存控制策略。

###### 错误状态管理
新增了24个错误状态响应码

###### 范围请求
HTTP/1.1在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接，支持断点续传

###### Host头
HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础

###### 持久连接
HTTP/1.1 最大的变化就是引入了持久连接（persistent connection），在HTTP/1.1中默认开启 Connection: keep-alive，即TCP连接默认不关闭，可以被多个请求复用。客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接

###### 管道机制
HTTP/1.1中引入了管道机制（pipelining）,即在同一个TCP连接中，客户端可以同时发送多个请求

#### HTTP/1.1的缺点
HTTP/1.1 的持久连接和管道机制允许复用TCP连接，在一个TCP连接中，也可以同时发送多个请求，但是所有的数据通信都是按次序完成的，服务器只有处理完一个回应，才会处理下一个回应。比如客户端需要A、B两个资源，管道机制允许浏览器同时发出A请求和B请求，但服务器还是按照顺序，先回应A请求，完成后再回应B请求，这样如果前面的回应特别慢，后面就会有很多请求排队等着，这称为"队头阻塞(Head-of-line blocking)"

#### HTTP2.0
HTTP2.0协议只在HTTPS环境下有效，解决了HTTP1.1的性能问题

###### 二进制分帧
头信息和数据体均为二进制，统称为帧

###### 多路复用、双工通信
单一HTTP2.0连接发起多重请求-响应消息，不用按照顺序一一对应，避免了“头部阻塞”，并行地在同一个TCP连接中双向交换信息

###### 数据流
HTTP2.0中数据包不按顺序发送，因此需要对同一请求或响应的所有数据包打上==数据流ID==。HTTP2.0可以在数据流发送过程中==取消数据流==，而同时保持TCP连接（HTTP1.1实现这一点的唯一方法是关闭TCP连接）。此外可以指定==数据流优先级==。

###### 首部压缩
由于HTTP不带有状态，因此每次请求需要附上所有信息，并且很多字段都是重复的。HTTP2.0引入头信息压缩机制：1. 专用的HPACK首部压缩算法，2. 客户端和服务器同时维护一张头信息表，通过只发送索引号提高速度

###### 服务器推送
允许服务器未经请求，主动向客户端发送资源。例如服务器可以预期到客服端请求网页后，很可能再请求静态资源，所以主动将这些静态资源随着网页一起发送


