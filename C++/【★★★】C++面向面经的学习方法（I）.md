## 1、new 与 malloc 的异同处
#### 属性
- malloc/free 是==库函数==，需要头文件的支持；
- new/delete 是==关键字==，需要编译器的支持

#### 参数
- new 申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算；
- malloc 在申请空间时，需要确定所申请空间的大小

#### 返回值
- new 申请空间时，返回的类型是对象的指针类型，无需强制类型转换，符合类型安全的操作符；
- malloc 申请空间时，返回的是 void* 类型，需要进行强制类型的转换，转换为对象类型的指针

#### 分配失败
- new 分配失败时，会抛出 bad_alloc 异常
- malloc 分配失败时返回空指针

#### 重载
- new/delete 支持重载
- malloc/free 不能进行重载

#### 自定义类型实现
- new 首先调用 operator new 函数申请空间（底层通过 malloc 实现），然后调用构造函数进行初始化，最后返回自定义类型的指针；delete 首先调用析构函数，然后调用 operator delete 释放空间（底层通过 free 实现）。
- malloc/free 无法进行自定义类型的对象的构造和析构

#### 内存区域：
- new 操作符从自由存储区上为对象动态分配内存
- malloc 函数从堆上动态分配内存。（自由存储区不等于堆）
- 自由存储器是C++中动态内存分配释放的抽象概念，而堆是C语言和操作系统属于，C++标准中没有给予两者联系的详细说明，特定情况下new/delete可以通过malloc/free来实现，也可以用全局变量做的内存池


## 2、指针和引用的区别
#### 本质：指针和引用都是地址的概念
- 指针指向一块内存，它的内容是所指向的地址，程序为指针型变量分配内存区域
- 引用是某块内存的别名，不分配内存

#### 使用上的区别
###### 访问内容
指针要加*，而引用不需要

###### 是否可以改变
- 引用在定义时初始化，之后无法改变
- 指针可以改变指向的对象

###### 是否可以为空
- 不存在空引用
- 但有空指针
- 在不确信指针指向的是否为空时，指针访问前总应该被测试是否为空，使得==使用引用的代码效率更高==

###### sizeof()
- sizeof(引用)得到变量大小
- sizeof(指针)得到变量地址的大小

###### 是否存在多级
存在指针的指针，不存在引用的引用

###### ++运算的不同
- ++引用改变所指向的对象
- ++指针使得指针指向下一个对象

## 3、struct和class的区别
#### 默认的继承访问权
- class默认为private，struct默认为public
- 继承访问权取决于==子类==而非基类

#### 默认的访问权限
class默认为private，struct默认为public

#### 模板参数
class允许定义模板参数，而struct不可

#### C++对C的扩展——struct的增强
1. struct也能定义成员函数
2. struct也能实现继承
3. struct也能实现多态
4. struct也能定义访问权限

#### 总结：C++中struct在实现对C兼容的基础上，做了一些扩展使其更适合面向对象，struct更适合一个数据结构的实现体，而class更适合一个对象的实现体

## 4、#define和const的区别
在C++中#define和const都可以用于定义一些常量

#### 类型安全性
- define没有数据类型，不进行安全性检查
- const有数据类型，可以避免一些低级错误

#### 调试方面
- const常量可以进行调试，而define 不可

#### 起作用阶段
- #define编译阶段，const是编译、运行阶段

#### 其他
为了提升效率，const常量编译时可能会放置在符号表中，避免了访存的延时

## 5、计算一个类的大小：非静态成员变量 + 内存对齐开销 + 虚函数开销
#### 遵循以下原则：
- 类的大小遵循结构体的对齐规则
- 类的大小与普通成员函数和静态成员无关（包括：普通成员函数、静态成员函数、静态数据成员、静态常量数据成员），与普通数据成员有关
- 虚函数对类的大小有影响，是因为虚函数指针的影响
- 虚继承对类的大小有影响，是因为虚基表指针带来的影响
- 空类的大小是 1

#### 为何没有成员函数的信息？
成员函数在编译期间确定，对象在调用时直接call函数名去调用，所以不需要在对象中存储成员函数信息。（在后面==II==图示中很清晰明了）

#### 很奇妙的现象
```
class A{
private:
    int a;
public:
    virtual void print(){ cout << "A" << endl; }
};

class B : public A{
public:
    virtual void print(){ cout << "B" << endl; }
};
```
A的大小为16是很显然的，但B的大小居然也是16！虽然B无法访问到a，但它还是被算在大小之中

参考这篇，写得很好，图文并茂：
- https://www.cnblogs.com/BEN-LK/p/10720337.html

