## 1、进程与线程
#### 进程
进程是系统资源分配和调度的单位，是运行中的程序（程序是静态概念，进程是动态概念）.

#### 线程
线程是独立调度的基本单位，一个进程中可以有多个进程，共享进程中全部系统资源（虚拟地址空间、文件描述符、信号处理等），拥有各自的调用栈、寄存器环境。

#### 区别
- 拥有资源：进程是资源分配的基本单位，线程不拥有资源，可以访问隶属进程的资源
- 调度：线程时独立调度的基本单位，同一进程中线程切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换
- 系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。
- 通信方面：线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

## 2、进程调度算法
#### FCFS 先来先服务调度算法
非抢占式，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性、后台任务），不利于短作业（I/O繁忙性，前台任务）

#### SJF短作业优先
非抢占式，优先照顾短作业，性能好，平均等待时间低（这对于前台交互是非常友好的），但不利于长作业甚至使得长作业饥饿，不能用于实时系统

#### 最短剩余时间优先
抢占式，当有新作业到达并且剩余服务时间短，则进行抢占，频繁的抢占与切换，系统开销大，一般用于实时系统（完成截止时间的保证）

#### 高响应比优先
非抢占式，计算所有作业中响应比（等待时间 / 服务时间 + 1）中最高的，（已等待的时间很长，或者服务时间很短），介于FCFS和SJF之间

#### 时间片轮转
简单有效，常用于分时系统，不利于I/O型作业（用不到一个时间片就讲因为发生I/O读写而阻塞）

#### ==多级反馈队列调度算法==
结合以上多种算法的折中解
- 设置多级队列，优先级从高到低，时间片从小到大
- 新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾。
- 只有第k级队列为空时，才会为k+1级队头的进程分配时间片

对各类型进程相对公平(FCFS的优点)；每个新到达的进程都可以很快就得到响应(RR优点)；短进程只用较少的时间就可完成(SPF优点)；不必实现估计进程的运行时间；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程(拓展：可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先)


## 3、进程通信
（与进程同步的区分，进程同步是一种目的，进程通信是手段，为了实现进程同步通常需要进行进程通信）

#### 管道
匿名管道PIPE与命名管道FIFO，详细描述见——==Linux系统编程之管道==

#### 信号signal
信号机制是unix系统中最为古老的进程间通信机制，定义于<signal.h>中

#### 消息队列
消息的链接表，存放在内核中，Linux中消息队列定义与<sys/msg.h>中。有如下特点：
1. 面向记录，其中的消息有特定的格式和优先级
2. 独立于接收和发送进程，进程终止时，消息队列中的内容不会删除
3. 可以实现消息的随机查询，不一定先进先出

#### 信号量+共享内存
- 信号量：一个用于为多个进程提供对共享数据对象的访问的计数器，基于操作系统的PV操作（均为原子操作），Linux信号量定义于<sys/sem.h>中
- 共享内存：指定多个进程共享一个给定的存储区，Linux共享内存定义于<sys/shm.h>中，当共享内存被创建后，先要映射到当前进程的地址空间，之后可以当做本地内存一样访问

#### 套接字
可用于不同主机上进程之间的通信，UDP and TCP

## 4、线程的同步与通信
同一进程中的线程已经共享进程的虚拟内存空间，因此可以直接通过同步和互斥访问临界区实现数据的交换。而不同进程中的线程则需要采用进程间通信的方式。

#### 互斥锁
对互斥锁加锁后，其他试图再次对该互斥锁加锁的线程将被阻塞直至当前线程释放该互斥锁

```c
pthread_t mutex;
pthread_mutex_init(&mutex, NULL);
pthread_mutex_lock(&mutex);
...
pthread_mutex_unlock(&mutex);
pthread_mutex_detroy(&mutex);
```

#### 读写锁
读写锁具有更高的并行性，只能有一个线程可以占有写模式的读写锁，但多个线程可以同时占有读模式的读写锁。

```c
int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *rwlockattr);//初始化读写锁
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);//销毁读写锁
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);//读模式锁定读写锁
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);//写模式锁定读写锁
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);//解锁读写锁
```

#### 条件变量
互斥量用于上锁，而条件变量用于等待，并且条件变量总是要和互斥量一起使用（条件变量本身是由互斥量保护的），运行线程以无竞争的方式等待特定条件的发生。

```c
pthread_mutex_t mutex;
pthread_cond_t cond;
...
pthread_mutex_lock(&mutex);
pthread_cond_wait(&cond, &mutex);
...
pthread_mutex_unlock(&mutex);
```
上述执行流程描述：
1. 先对mutex加锁，保护条件变量
2. pthread_cond_wait先将mutex解锁，等待条件变量被唤醒，否则线程将休眠，阻塞于该函数的调用中。
3. 线程被唤醒后，自动对mutex加锁，再进行条件判断（为什么？——==“惊群效应”==，如果多个线程都在等待同一个条件，而只能有一个线程进行处理，因此需要再次条件判断），如果满足，线程继续执行
4. 对mutex解锁，退出临界区

#### 信号量
线程的信号量与进程的信号量类似，实际上是一个非负的整数计数器，公共资源增加时，信号量增加，反之则减少，只有信号量>=0时，公共资源才能被访问。

```c
#include <semaphore.h>
sem_t sem_event;
int sem_init(sem_t *sem, int pshared, unsigned int value);//初始化一个信号量 
int sem_destroy(sem_t * sem);//销毁信号量
int sem_post(sem_t * sem);//信号量增加1
int sem_wait(sem_t * sem);//信号量减少1
int sem_getvalue(sem_t * sem, int * sval);//获取当前信号量的值
```

#### 自旋锁
自旋锁与互斥锁类似，但它不通过休眠而使得线程阻塞，而是一直处于忙等状态（此谓“自旋”），可用于以下情况：锁持有时间较短，线程不希望在重新调度上花费太多的成本

#### 屏障
屏障是指用户可以协调多个线程并行工作的同步机制，屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从改点继续执行。
