## 单一职责原则S
- 通俗地讲就是，一个类只做一件事
- 最常见的例子：STL中的迭代器，迭代器放到容器类中可能会暴露容器的内部结构（不符合封装性），对容器的遍历访问会有很多种要求，分离的实现可以不修改容器而是仅定制迭代器即可（可扩展性）

## 开放封闭原则O
- 所谓封闭，是对修改的封闭，设计好的类，里面的方法等最好不要去修改；所谓开放，是对扩展的开放，在不改变原有实现的前提下，可以通过继承和多态来实现，把公共的部分==抽象==出来
- 举例：一个实现服务器功能的类，想要再添加客户端功能，不应该直接往里面添加，而是将公共部分抽象出一个类，让服务器类和客户端类去继承他

## 里式替换原则L
- 子类应当可以替换父类并出现在父类的任何地方
- 举例：从长方形中抽象出正方形，当计算面积的时候，正方形是边长的平方，替换长方形后可能会有问题。

```cpp
class BaseClass{
    public:
        int add(int a, int b){return a+b;}
}
 
class SubClass: public BaseClass{
    public:
        int add(int a, int b){return a-b;}
        void print(){};
}
 
void method(const BaseClass& base){
     base.add(1,2);
}
 
BaseClassbase;
SubClasssub;
method(base);
method(sub);
```

这样一段代码也有违里式替换原则，因为子类的add()方法覆盖了父类的add()

## 接口隔离原则I
- 接口多使用小的专门的接口，而不要使用一个大的总接口

## 依赖倒置原则D
- 依赖倒置指实现依赖于抽象，高层模块不依赖于底层模块，因为抽象的变换很少，而具体实现的细节可能一直在变。